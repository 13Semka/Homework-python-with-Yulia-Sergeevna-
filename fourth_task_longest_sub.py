def longestUniqueSubstr(s):
    longest_substr = 0          # базово у нас самая длинная строка пока ноль
    last_index = [-1] * 256     # создаем список из 256 элементов со значениями -1, чтобы отслеживать посещения буковок в строке
    left = 0                    # буду использовать метод "окна", и как бы выцеплять подстроку в промежутке от левого до правого
    for right in range(len(s)): # цикл, в котором проходимся по все ренжу нашей строчки
        left = max(left, last_index[ord(s[right])] + 1)         # тут самое интересное, выбираем максимальное значение из левого и из
        # сложной строчки, но сложного по сути ничего, мы берем элемент из списка last_index, котороый соответствует букве, на которой
        # сейчас находится right, если мы его не посещали, то там будет -1, и в любом сравнении оно будет проигрывать ну или 0=0
        # а если посещали, то оно будет больше чем left, и мы меняем значение left
        longest_substr = max(longest_substr, right - left + 1)  # тут смотрим, а больше ли эта подстрока, чем уже записанное значение или нет
        last_index[ord(s[right])] = right                       # а тут как раз таки обновляем, например если прошли букву a
        # то взяли от нее ord ord(a) = 97 (просто скажем айди буквы "а" в юникоде, записываем в ее значение - ее позицию в строке)

    return longest_substr
